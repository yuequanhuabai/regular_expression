入门示例扩展

$/ =".\n";
while(<>){
    next if !s/\b([a-z]+)((?:\s/<[^>]+>)+)(\1\b)/\e[7m$1\e[m$2\e[7m$3\e[m/ig;]]]]
    s/^(?:[^\e]*\n)+      //mg;  #去除未标记的行
    s/^/$ARGV:   /mg;     #  在行首添加文件名
    print;
}

该程序的主要功能依靠3个正则表达式：
--  \b([a-z]+)((?:\s|<[^>]+>)+)(\1\b)
--  ^(?:[^\e]*\n)+
--  ^


验证用户的输入数据，处理E-mail header(电子邮件头)，把纯文本转换为超文本格式(html)

正负浮点数的表达方式：  [-+]?[0-9]+(\.[0-9]*)?

第五章-->194页；

137页


分组，捕获

\s 匹配所有的"空白";
\t 代表制表符，而\s则能表示所有表示“空白字符”的字符组，其中包括空格符、制表符、换行符、回车符。


/g global match  全局匹配；

Perl   $variable =~ m/regex/ 来判断一个正则表达式是否能匹配某个字符串；

\t 制表符
\n 换行符
\r 回车符
\s 任何“空白”字符 （例如空格符，制表符，进纸符等）
\S 除\s之外的任何字符
\w [a-zA-Z0-9] (在 \w+ 中很有用，可以用来匹配一个单词)
\W 除 \w 之外的任何字符，也就是[^a-zA-Z0-9]
\d [0-9],即数字
\D 除 \d 外的任何字符，即[^0-9]

(?:...) 这个麻烦的写法可以用来分组文本，但并不捕获。

匹配成功后，Perl可以用$1,$2,$3之类的变量来保存相应的(...)括号内的子表达式匹配的文本。
使用这些变量，我们能够用正则表达式从字符串中提取信息


使用正则表达式修改文本

$var =~ m/regex

$var =~ s/regex/replacement
如果正则表达式能够匹配$var中的某段文本，则将这段匹配的文本替换为replacement.


$var =~ s/\bJeff\b/Jeffrey/

s  substitution 替换


perl -p -i -e 's/sysread/read/g' file
这是一个完整的Perl程序，参数-e 表示整个程序接在命令的后面，
参数-p 表示对目标文件的每一行进行查找和替换，
而 -i 表示将替换的结果写回到文件


perl -w mkreply king.in >king.out


Jeffs 替换为Jeff's 的几种方法:

s/\bJeffs\b/Jeff's/g 

s/\b(Jeff)(s)\b/$1'$2/g 

s/\bJeff(?=s\b)/Jeff'/g 

s/(?<=\bJeff) (?=s\b)/'/g 

s/(?=s\b) (?<=\bJeff)/'/g 

(?=...)  右边是某字符串或某个字符
(?<=...) 左边是某字符串或某个字符
结合上面两个： 在右边是字符串某某1和在左边是字符串某某2的位置重合的地方插入某某字符(或字符串)

环视
298444215 ---> 298,444,215
逗号加在左边有数字，右边数字的个数正好是3的倍数的位置

顺序环视： 
    特殊序列(?=...) 例如：(?=\d) 表示如果当前位置右边的字符是数字则匹配成功
逆序环视：
    (?<=...) 例如： (?<=\d) 表示如果当前位置左边有一位数字则匹配成功

$pop =~ s/(?<=\d)(?=(\d\d\d)+$)/,/g;

print "The US population is $pop\n";

捕获型的括号(?<=...)
非捕获型的括号(?:...)  专助于分组；不用担心与捕获型括号关联的$1是否会用到，它的效率更高，因为引擎不需要记忆捕获的文本

(?<=\d)(?=(?:\d\d\d)+$)

$text =~ s/(?<=\d)(?=(\d\d\d)+(?!\d))/,/g 


肯定顺序环视：(?<=...)    子表达式能够匹配左侧文本
肯定逆序环视：(?<!...)    子表达式不能匹配左侧文本

否定顺序环视： (?=...)    子表达式能够匹配右侧文本
否定逆序环视： (?!...)    子表达式不能匹配右侧文本

不通过逆序环视解决以上问题：

$text =~ s/(\d) (?=(\d\d\d)+(?!\d))/$1,/g;

$text =~ s/(\d)(?=(\d\d\d)+\b)/$1,$2/g;  (只是单次，不能实现)

& 、<、>
&amp, &lt, &gt


$text =~ s/&/&amp;/g;    #保证基本的html
$text =~ s/</&lt;/g;     # ...字符 &、<、and > ...
$text =~ s/>/&gt;/g;     # ...转换后不出错


分隔段落

$text =~ s/^$/<p>/g;

$text =~ s/^$/<p>/mg;

处理匹配空格字符   ^ *$ 或者 ^[ \t\r]*$
与 ^$ 完全不同，因为它们确实匹配了一些字符，而^$只匹配位置。

^\s$ 能够匹配 “连续、空行和只包括空白字符的行的结合”。

$text =~ s/^[ \t\r]*$/<p>/mg;

$text =~ s/^\s*$/<p>/mg;

最终使用^\s*$

email 转换未超链接形式：

$text =~ s/\b(username regex\@hostname regex)\b/<a href="mailto:$1">$1<\/a>/g;

Perl 中查找替换的基本形式是 s/regex/replacement/modifier

$text =~ s{\b(username regex\@hostname regex)\b}{<a href="mailto:$1">$1</a>}gi;


综合起来

undef $/;       #进入“文件读取”模式
$text =<>;      #读入命令行中指定的第一个文件名
$text =~ s/&/&amp;/g;       #把基本的HTML...
$text =~ s/</&lt;/g;        #...字符 &、< 和 > ...
$text =~ s/>/&gt;/g;        #...进行HTML转义

$text =~ s/^\s*$/<p>/mg;    # 划分段落

# 转换为链接形式...
$text =~ s{
    \b
    # 把地址保存到$1...
    (
        \w[-.\w]*                                   # username
        \@
        [-a-z0-9]+(\.[-a-z0-9]+)*\.(com|edu|info)   # housename
    )
    \b
}{<a href="mailto:$1">$1</a>}gix;

print $text;        #最后，显示HTML文本

构建正则表达式：
$HostnameRegex = qr/[-a-z0-9]+(\.[-a-z0-9]+)*\.(com|edu|info)/i;

#将E-mail 地址转为未链接形式...

$text =~ s{
    \b
    #将地址保存至$1...
    (
        \w[-.\w]*
        \@
        $HostnameRegex
    )
    \b 
}{<a href="mailto:$1">$1</a>}gix;

# 将http url 转化为链接的形式...

$text =~ s{
    \b 
    # Capture the URL to $1 ...
    (
        http:// $HostnameRegex \b 
        (
            / [-a-z0-9_:\@&?=+,.!/~*'%\$]*          # path 不一定会出现
            (?<![.,?!])                             #不容许以[.,?!]结尾
        )
    )
}{<a href="$1">$1</a>}gix;